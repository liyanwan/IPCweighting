```{r setup, include=FALSE}
rm(list = ls())
```

```{r}
true_survival_function <- function(dist,time,params = list()){
  # Exponential S(t) = exp(-lambda*t)
  # Weibull S(t) = exp(-(lambda*t)^alpha)
  # Log Normal S(t) = 1-CDF((ln(t) - mean)/sd), CDF() here is the CDF of standard normal
  # Log Logistic S(t) = 1/(1+(lambda*t)^alpha)
    if (dist == "exponential") {
    return(exp(-params$lambda_base * time))
  } else if (dist == "Weibull") {
    return(exp(-(params$lambda_base * time)^params$alpha))
  } else if (dist == "log-normal") {
    return(exp(plnorm(time, meanlog = params$mean, sdlog = params$sd, lower = FALSE, log = TRUE)))
  } else if (dist == "log-logistic") {
    return(1 / (1 +(params$lambda_base * time)^params$alpha))
  } else {
    stop("Error: Unsupported distribution.")
  }
}

ols_error <- function(true_surv, est_surv) {
  return(sum((true_surv - est_surv)^2))
}
```

```{r}
get_status <- function(observed_time, sigma, time_point){
  # Calculate the time_point-year event status. The common symbol is E
  # Arguments:
  #   observed_time: Numeric vector of observed times.
  #   sigma: Numeric vector indicating censoring status (1: uncensored, 0: censored).
  #   time_point: Numeric value specifying the time point of interest.
  # Returns:
  #   A numeric vector of the same length as observed_time, containing the event indicator
  E_obs <- ifelse(observed_time <= time_point & sigma == 1, 1, ifelse(observed_time > time_point, 0, NA))
  return(E_obs)
}
```

```{r}
get_cat_X <- function(X, num_obs, values, probs, name){
  if (length(values) != length(probs)) {
    stop("Error: 'values' and 'probs' must have the same length.")
  }
  if (sum(probs) != 1) {
    stop("Error: The probabilities 'probs' must sum to 1.")
  }
  partial <- sample(values, size = num_obs, replace = TRUE, prob = probs)
  if (ncol(X) == 0) {
    X <- data.frame(partial)
  } else {
    X <- cbind(X, partial)
  }
  colnames(X)[ncol(X)] <- name
  
  return(X)
}

get_cont_X <- function(X, distribution, num_obs, para1, para2, name) {
  if (distribution == 'uniform') {
    if(para1<para2){
      partial = runif(num_obs, para1, para2)
    } else{
      stop("Error: 'para1' must be less than 'para2' for uniform distribution.")
    }
    mean <- (para2 + para1) / 2
    
  } else if (distribution == "gaussian") {
    if(para2 > 0){
      partial = rnorm(num_obs, para1, para2)
    } else{
      stop("Error: 'para2' (standard deviation) must be positive for Gaussian distribution.")
    }
    mean <- para1
    
  } else if (distribution == 'exponential') {
    if(para1 > 0){
      partial = rexp(num_obs, para1)
    } else{
      stop("Error: 'para1' (rate) must be positive for exponential distribution.")
    }
    mean <- 1 / para1
  } else {
    stop("Error: Unsupported distribution. Choose 'uniform', 'gaussian', or 'exponential'.")
  }
  if (ncol(X) == 0) {
    X <- data.frame(partial)
  } else {
    X <- cbind(X, partial)
  }
  colnames(X)[ncol(X)] = name
  mean_X <<- c(mean_X, mean)
  return(X)
}
```

```{r}
sim_censor_time <- function(dist = "exponential", n, params = list()){
  # Simulate censoring time
  if (dist == "exponential") {
    if (!is.null(params$lambda)) {
      return(rexp(n, rate = params$lambda))
    }
    else{
      stop("Please input the correct parameters.")
    }
  } 
  else if (dist == "Weibull") {
    if (!is.null(params$lambda) & !is.null(params$alpha)) {
      return(rweibull(n, shape = params$alpha, scale = 1/params$lambda))
    }
    else{
      stop("Please input the correct parameters.")
    }
  } 
  else if (dist == "log-logistic") {
    # Log-logistic distribution using qlogis for quantiles
    if (!is.null(params$lambda) & !is.null(params$alpha)) {
      u <- runif(n)
      return((1/(params$lambda))* (u / (1 - u))^(1 / params$alpha))
    }
    else{
      stop("Please input the correct parameters.")
    }
  } 
  else if (dist == "log-normal") {
    if (!is.null(params$mean) & !is.null(params$sd)) {
      return(rlnorm(n, meanlog = params$mean, sdlog = params$sd))
    }
    else{
      stop("Please input the correct parameters.")
    }
  } 
  else if (dist == "uniform"){
    if(!is.null(params$start) & !is.null(params$end)){
      censor_time = runif(n, params$start,params$end)
    }
    else{
      stop("Please input the correct parameters.")
    }
  } 
  else {
    stop("Unsupported distribution")
}
}
```

```{r}
sim_beta <- function(prop, time_point, mean_X){
  # Simulate true beta (except beta0)
  # if(dist == "uniform"){
  #   true_beta = runif(nums, params$start, params$end)
  # }
  # else if(dist == "middle-high"){
  #   true_beta = rlaplace(nums, mu = 0, sigma = params$sigma)
  # }
  constant = -log(prop*time_point)
  objective_function <- function(beta, x, constant) {
    return((sum(x * beta) - constant)^2)
    }
  initial_beta = rep(1, length(mean_X))
  result = optim(initial_beta, objective_function, x = mean_X, constant = constant)
  beta_solution = result$par
  return(beta_solution)
  
  return(true_beta)
}
```

```{r}
simulate_U <- function(n) {
  # It is a helper function of sim_T below Simulate S(t|X_i) = U.
  # U ~ unif(0.01,0.25) with probability 0.4
  # U ~ unif(0.25, 0.5) with probability 0.35
  # U ~ unif(0.5, 0.75] with probability 0.15
  # U ~ unif(0.75, 1) with probability 0.1
  simulated_values = numeric(n)
  probs = c(0.4, 0.35, 0.15, 0.1)
  intervals = matrix(c(0.01, 0.25, 0.25, 0.5, 0.5, 0.75, 0.75, 0.99), ncol = 2, byrow = TRUE)
  cum_probs = cumsum(probs)
    for (i in 1:n) {
      U = runif(1)
      if (U <= cum_probs[1]) {
        simulated_values[i]= runif(1, intervals[1, 1], intervals[1, 2]) 
        # Simulate from (0, 0.25]
      } else if (U <= cum_probs[2]) {
        simulated_values[i] = runif(1, intervals[2, 1], intervals[2, 2])  
        # Simulate from (0.25, 0.5]
      } else if (U <= cum_probs[3]) {
        simulated_values[i] = runif(1, intervals[3, 1], intervals[3, 2])  
        # Simulate from (0.5, 0.75]
      } else {
        simulated_values[i] = runif(1, intervals[4, 1], intervals[4, 2])  
        # Simulate from (0.75, 1]
      }
    }
  return(simulated_values)
}
```

```{r}
sim_T <- function(dist, n, params=list(), U_notuni){
  # Simulate event time based on baseline survival function
  # If baseline survival follows exponential distribution, event time is simulated directly
  # In other cases, simulate events times by suing the inverse of the cumulative hazard function (Using helper function)
  if (dist == "exponential") {
  if (!is.null(params$lambda_base) & !is.null(params$lc)) {
    return(rexp(n, rate = (params$lambda_base*exp(params$lc))))
  }
} else if (dist == "Weibull") {
  if (!is.null(params$lambda_base) & !is.null(params$alpha)& !is.null(params$lc)) {
    if(U_notuni){
      U = simulate_U(n)
    } else{
      U = runif(n, 0, 1)
    }
    return(1/params$lambda_base*(-log(U)/exp(params$lc))^(1/params$alpha))
  }
} else if (dist == "log-logistic") {
  if (!is.null(params$lambda_base) & !is.null(params$alpha)) {
    U = simulate_U(n)
    return((1/(params$lambda_base)) * ((1-U^(1/exp(params$lc))) / U^(1/exp(params$lc)))^(1 / params$alpha))
  }
} else if (dist == "log-normal") {
  if (!is.null(params$mean) & !is.null(params$sd)& !is.null(params$lc)) {
    U = simulate_U(n)
    S_t = 1-U^(1 / exp(params$lc))
    return(exp(qnorm(1 - S_t) * params$sd + params$mean))
  }
} else {
  stop("Unsupported distribution")
}
}
```

```{r}
Get_Ghat <-function(time_point, full_dt){
  # A helper function, using Kaplan Meier estimator of survival distribution of the censoring times.
  km_censor = survfit(Surv(observed_time, 1-sigma)~1, data = full_dt)
  survest_Xi = stepfun(km_censor$time, c(1, km_censor$surv))
  return(survest_Xi)
}
```

```{r}
check_time_vs_status <- function(dt){
  # return a table shows the number of E=0, E=1, E unknown, respectively
  num_E_1 = sum((get_status(dt$observed_time, dt$sigma, 5)) == 1, na.rm = TRUE)
  num_E_0 = sum((get_status(dt$observed_time, dt$sigma, 5)) == 0, na.rm = TRUE)
  num_E_unknown = sum(is.na(get_status(dt$observed_time, dt$sigma, 5)))
  status_table = data.frame(status = c("E = 1", "E = 0", "E unknown"),
                            Count = c(num_E_1, num_E_0, num_E_unknown),
                            stringsAsFactors = FALSE)
  colnames(status_table)[1] = paste("Status_before_year_", time_point, sep = "")
  return(status_table)
}
```

```{r}
check_censor_in_time_interval<- function(dt,time_point){
  # return a table shows the number of observations censored between i-1 and i, where i=1,2,..., time_point
  result_table =data.frame(Time_Interval = character(),
                         Count = integer(),
                         stringsAsFactors = FALSE)
  for (i in 1:time_point) {
    count = nrow(dt[dt$sigma == 0 & dt$observed_time >= i - 1 & dt$observed_time <= i, ])
    result_table = rbind(result_table, 
                          data.frame(Time_Interval = paste(i-1, "to", i), 
                                     Count_Censored_Data_in_Time_Tnterval = count))
  }
  return(result_table)
}
```