---
title: "IPCW"
author: "Liyan Wang"
date: "2024-09-15"
output: html_document
---

```{r}
rm(list = ls())
```

```{r}
true_survival_function <- function(lambda, time, p=1){
  return(exp(-lambda*time^p))
}

ols_error <- function(true_surv, est_surv) {
  return(sum((true_surv - est_surv)^2))
}
```

```{r}
get_status <- function(observed_time, sigma, time_point){
  # Calculate the time_point-year event status
  # Arguments:
  #   observed_time: Numeric vector of observed times.
  #   sigma: Numeric vector indicating censoring status (1: uncensored, 0: censored).
  #   time_point: Numeric value specifying the time point of interest.
  # Returns:
  #   A numeric vector of the same length as observed_time, containing the event indicator
  E_obs <- ifelse(observed_time <= time_point & sigma == 1, 1, ifelse(observed_time > time_point, 0, NA))
  return(E_obs)
}
```

```{r}
get_cat_X <- function(X, num_obs, values, probs, name){
  # Generate a categorical covariate
  # Arguments:
  #   num_obs: the number of individuals.
  #   values: Numeric vector indicating potential values of the categorical covariate.
  #   probs: Numeric vector indicating the probability of the corresponding value.
  #   name: The (column) name of the categorical variable.
  # Returns:
  #   X: The updated covariate dataframe.
  partial = sample(values, size = num_obs, replace = TRUE, prob = probs)
  if (ncol(X) == 0) {
    X = data.frame(partial)
  } else {
    X <- cbind(X, partial)
  }
  colnames(X)[ncol(X)]= name
  return(X)
}

get_cont_X <- function(X, distribution, num_obs, para1, para2,name){
  # Generate a continuous covariate
  # Arguments:
  #   num_obs: the number of individuals.
  #   distribution: The distribution that the covariate simulates.
  #   name: The (column) name of the continuous variable.
  # Returns:
  #   X: The updated covariate dataframe.
  if(distribution=='uniform'){
    partial = runif(num_obs, para1, para2)
    mean = (para2+para1)/2
  } else if(distribution == "gaussian"){
    partial = rnorm(num_obs, para1, para2)
    mean = para1
  } else if(distribution == 'exponential'){
    partial = rexp(num_obs, para1)
    mean = 1/para1
  }
  
  if (ncol(X) == 0) {
    X = data.frame(partial)
  } else {
    X <- cbind(X, partial)
  }
  
  colnames(X)[ncol(X)] = name
  mean_X <<- c(mean_X, mean)
  return(X)
}
```

```{r}
get_T <- function(distribution, num_obs,lambda,seed){
  # t = data.frame()
  if(distribution == "exponential"){
    # for (i in 1:seed){
    #   t=cbind(t,rexp(num_obs, rate = lambda))
    # }
    # return(rowMeans(t))
    return(rexp(num_obs, rate = lambda))
  }else if(distribution =="Weibull"){
    # scale_param <- dt$lambda^(-1/p)
    # for (i in 0:seed){
    #   t=cbind(t,rweibull(num_obs, shape = p, scale = scale_param))
    # }
    # return(rowMeans(t))
    return(rweibull(num_obs, shape = p, scale = scale_param))
  }
}
```

```{r}
get_C <- function(distribution, num_obs,uncensor_prop, lambda,seed){
  # TODO: Generates censoring times for a given distribution and desired proportion of uncensored observations.
  # Ensure that the `uncensor_prop` is within the valid range (0, 1)
  if (uncensor_prop <= 0 || uncensor_prop >= 1) {
    stop("`uncensor_prop` must be between 0 and 1.")
  }
  censor_time = rexp(num_obs, rate = ((1-uncensor_prop)/uncensor_prop)*lambda) 
  # this means P(T_i<C_i) = uncensored_prop
  return(censor_time)
}
```

```{r}
naive_estimate <- function(dt, time_point, var_name){
  # Estimates survival probability at a given time point using a naive logistic regression approach.
  # Arguments:
  #   time_point: Numeric value specifying the time point of interest.
  #   var_name: A vector containing the names of all covariates to be included in the model.
  # Returns:
  #   A vector of predicted survival probabilities for each observation at the specified time point.
  naive_data = dt[!is.na(dt$E),]  # drop observations with unknown E
  formula_str <- paste("E ~", paste(var_name, collapse = " + "))
  formula <- as.formula(formula_str)
  # Apply logistic regression on naive_data, where P(E=1|X) = P(T<=time_point|X)
  naive_model = glm(formula, data = naive_data, family = binomial)  
  # Obtain predict survival probability at time_point
  naive_pred_prob = 1-(predict(naive_model, newdata = dt[var_name], type = "response"))
  return(naive_pred_prob)
}
```

```{r}
cox_estimate<-function(dt,newdt, var_name){
  formula_var = paste("Surv(observed_time, sigma) ~", paste(var_name, collapse = " + "))
  formula <- as.formula(formula_var)
  cox_model = coxph(formula, data = dt)
  coxph_pred_prob = predict(cox_model, newdata = newdt, type="survival")
  return(coxph_pred_prob)
}
```

```{r}
ipcw_estimate <- function(dt,time_point, var_name){
  # Estimates survival probability at a given time point using a naive logistic regression approach with IPCW.
  # Arguments:
  #   time_point: Numeric value specifying the time point of interest.
  #   var_name: A vector containing the names of all covariates to be included in the model.
  # Returns:
  #   A vector of predicted survival probabilities for each observation at the specified time point with IPCW.
  full_dt = dt
  #Apply Kaplan-Meier estimator of the survival distribution of the censoring times
  km_censor_Xi = survfit(Surv(observed_time, 1-sigma)~1, data = full_dt)
  survest_Xi = stepfun(km_censor_Xi$time, c(1, km_censor_Xi$surv))
  censor_prob_Xi = survest_Xi(ifelse(full_dt$observed_time<time_point, full_dt$observed_time,time_point))
  # Compute \hat{G(min(observed_time, time_point))}
  full_dt$G_hat_Vi = censor_prob_Xi
  full_dt$IPCW = ifelse(pmin(full_dt$event_time, time_point)<full_dt$censor_time, 1/full_dt$G_hat_Vi, 0) # Compute weights
  # View(full_dt)
  formula_str = paste("E ~", paste(var_name, collapse = " + "))
  formula = as.formula(formula_str)
  ipcw_logistic_model = glm(formula, data = full_dt, family = binomial, weights = IPCW)
  ipcw_pred_prob <- 1-(predict(ipcw_logistic_model, newdata = dt[var_name], type = "response"))
  return(ipcw_pred_prob)
}
```

```{r}
sim_beta <- function(beta_0,prop, time_point, mean_X){
  # Simulates a group of beta coefficients (excluding beta_0) such that E(event time) = prop*time_point
  # Returns:
  # The estimated beta coefficients (excluding beta_0) which minimize the sum of squared
  constant = -log(prop*time_point)-beta_0
  objective_function <- function(beta, x, constant) {
  return((sum(x * beta) - constant)^2)
  }
  initial_beta <- rep(1, length(mean_X))
  result <- optim(initial_beta, objective_function, x = mean_X, constant = constant)
  beta_solution <- result$par
  return(beta_solution)
}
```

