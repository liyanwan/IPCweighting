---
title: "IPCW"
author: "Liyan Wang"
date: "2024-09-15"
output: html_document
---
---
title: "ipcw3"
author: "Liyan Wang"
date: "2024-09-13"
output: pdf_document
---

```{r}
true_survival_function <- function(lambda, time, p=1){
  # Calculate the true survival function S(time)
  # Arguments:
  #   p: the rate of Weibull distribution. Default to 1 to assume survival function follows exponential distribution.
  # Returns:
  #   A numeric vector of the same length as lambda, indicating the theoretical probability of survival at time
  return(exp(-lambda*time^p))
}

ols_error <- function(true_surv, est_surv) {
  return(sum((true_surv - est_surv)^2))
}
```

```{r}
get_status <- function(observed_time, sigma, time_point){
  # Calculate the time_point-year event status
  # Arguments:
  #   observed_time: Numeric vector of observed times.
  #   sigma: Numeric vector indicating censoring status (1: uncensored, 0: censored).
  #   time_point: Numeric value specifying the time point of interest.
  # Returns:
  #   A numeric vector of the same length as observed_time, containing the event indicator
  E_obs <- ifelse(observed_time <= time_point & sigma == 1, 1, ifelse(observed_time > time_point, 0, NA))
  return(E_obs)
}
```

```{r}
get_cat_X <- function(X, num_obs, values, probs, name){
  # Generate a categorical covariate
  # Arguments:
  #   num_obs: the number of individuals.
  #   values: Numeric vector indicating potential values of the categorical covariate.
  #   probs: Numeric vector indicating the probability of the corresponding value.
  #   name: The (column) name of the categorical variable.
  # Returns:
  #   X: The updated covariate dataframe.
  partial = sample(values, size = num_obs, replace = TRUE, prob = probs)
  if (ncol(X) == 0) {
    X = data.frame(partial)
  } else {
    X <- cbind(X, partial)
  }
  colnames(X)[ncol(X)]= name
  return(X)
}

get_cont_X <- function(X, distribution, num_obs, para1, para2,name){
  # Generate a continuous covariate
  # Arguments:
  #   num_obs: the number of individuals.
  #   distribution: The distribution that the covariate simulates.
  #   name: The (column) name of the continuous variable.
  # Returns:
  #   X: The updated covariate dataframe.
  if(distribution=='uniform'){
    partial = runif(num_obs, para1, para2)
    mean = (para2+para1)/2
  } else if(distribution == "gaussian"){
    partial = rnorm(num_obs, para1, para2)
    mean = para1
  } else if(distribution == 'exponential'){
    partial = rexp(num_obs, para1)
    mean = 1/para1
  }
  if (ncol(X) == 0) {
    X = data.frame(partial)
  } else {
    X <- cbind(X, partial)
  }
  colnames(X)[ncol(X)] = name
  mean_X <<- c(mean_X, mean)
  return(X)
}
```

```{r}
get_C <- function(distribution, num_obs,uncensor_prop, lambda){
  if(distribution=='uniform'){
    censor_time = runif(num_obs, para1, para2)
  } else if(distribution == 'exponential'){
    censor_time = rexp(num_obs, rate = (1-uncensor_prop)/uncensor_prop*lambda) # this means P(T_i<C_i)=uncensored_prop
  } else if(distribution == 'lognormal'){
    censor_time 
  } else if(distribution == "Gamma"){
    censor_time 
  } else if (distribution == 'Beta'){
    censor_time 
  }
}
```

```{r}
get_T <- function(distribution, num_obs,lambda){
  if(distribution == "exponential"){
    return(rexp(num_obs, rate = lambda))
  }else if(distribution =="Weibull"){
    scale_param <- dt$lambda^(-1/p)
    dt$event_time = rweibull(num_obs, shape = p, scale = scale_param)
  }
}
```

```{r}
naive_estimate <- function(dt, time_point, var_name){
  # Arguments:
  #   dt: dataframe.
  #   time_point: Numeric value specifying the time point of interest.
  #   var_name: A vector contains the names of all covariates.
  true_surv_naive = true_survival_function(dt$lambda,time_point)
  naive_data = dt[!is.na(dt$E),]  # drop observations with unknown E
  formula_str <- paste("E ~", paste(var_name, collapse = " + "))
  print(formula_str)
  formula <- as.formula(formula_str)
  # Apply logistic regression on naive_data, where P(E=1|X) = P(T<=time_point|X)
  naive_model = glm(formula, data = naive_data, family = binomial)  
  # Obtain predict survival probability at time_point
  naive_pred_prob = 1-(predict(naive_model, newdata = dt[var_name], type = "response"))
  return(naive_pred_prob)
}
```

```{r}
ipcw_estimate <- function(dt,time_point, var_name){
  # Arguments:
  #   dt: dataframe.
  #   time_point: Numeric value specifying the time point of interest.
  #   var_name: A vector contains the names of all covariates.
  full_dt <- data.frame()
  full_dt = dt
  true_surv_ipcw = true_survival_function(dt$lambda,time_point)
  #Apply Kaplan Meier estimator of the survival distribution of the censoring times
  km_censor_Xi = survfit(Surv(observed_time, 1-sigma)~1, data = full_dt)
  survest_Xi = stepfun(km_censor_Xi$time, c(1, km_censor_Xi$surv))
  censor_prob_Xi = survest_Xi(ifelse(full_dt$observed_time<time_point, full_dt$observed_time,time_point))
  full_dt$G_hat_Vi = censor_prob_Xi
  full_dt$IPCW = ifelse(pmin(full_dt$event_time, time_point)<full_dt$censor_time, 1/full_dt$G_hat_Vi, 0) # Compute weights
  formula_str = paste("E ~", paste(var_name, collapse = " + "))
  formula = as.formula(formula_str)
  ipcw_logistic_model = glm(formula, data = full_dt, family = binomial, weights = IPCW)
  ipcw_pred_prob <- 1-(predict(ipcw_logistic_model, newdata = dt[var_name], type = "response"))
  return(ipcw_pred_prob)
}
```

```{r}
rm(list = ls())
```

```{r}
library(survival)
library(dplyr)
set.seed(123)
num_obs = 100000
dt = data.frame()
```

```{r}
# Generate Covariates
X = matrix(ncol = 0, nrow = 0)
mean_X = c()
X= get_cont_X(X, 'uniform',num_obs,1,4,"X1")
X = get_cont_X(X, 'uniform',num_obs,0.2,1,"X2")
```

```{r}
sim_beta <- function(beta_0,prop, time_point, mean_X){
  constant = -log(prop*time_point)-beta_0
  objective_function <- function(beta, x, constant) {
  return((sum(x * beta) - constant)^2)
}
  initial_beta <- rep(1, length(mean_X))
  result <- optim(initial_beta, objective_function, x = mean_X, constant = constant)
  beta_solution <- result$par
  return(beta_solution)
}
```

```{r}
time_point = 5
beta_0 = 0
beta = sim_beta(beta_0, 0.6, time_point, mean_X)

if (ncol(X)!=length(beta)){
  stop("X and beta are not multiplicable")
}

lambda = exp(beta_0+rowSums(sweep(X,2,beta,"*")))
dt = data.frame(lambda = lambda)
dt = cbind(dt,X)
var_name = colnames(X)
dt$event_time = get_T("exponential",num_obs, dt$lambda)
uncensor_prop = runif(1,0.4,0.6)
dt$censor_time = get_C("exponential",num_obs, uncensor_prop, lambda)
dt$observed_time = pmin(dt$event_time, dt$censor_time)
dt$sigma = as.numeric(dt$event_time<dt$censor_time)
dt$E = get_status(dt$observed_time, dt$sigma, time_point)

true_surv = true_survival_function(dt$lambda,time_point)
kakaka = naive_estimate(dt,time_point,var_name)
wulala = ipcw_estimate(dt,time_point, var_name)
ols_naive = ols_error(true_surv,kakaka)
ols_ipcw = ols_error(true_surv,wulala)
print(paste("sigma ==1 prop",sum(dt$sigma==1)/length(dt$sigma)))
# print("sigma ==1 prop",sum(dt$sigma==1)/length(dt$sigma))
print(paste("E==1 prop: ", sum(dt$E==1,na.rm=TRUE)/length(dt$E)))
print(paste("E==0 prop: ", sum(dt$E==0,na.rm=TRUE)/length(dt$E)))
```

