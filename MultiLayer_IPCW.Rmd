---
title: "Multilayer_IPCW"
author: "Liyan Wang"
date: "2024-09-21"
output: html_document
---
```{r}
rm(list = ls())
library(survival)
library(dplyr)
knitr::purl("~/IPCweighting/IPCWmethod.Rmd", output = "~/IPCweighting/IPCWmethod.R")
source("~/IPCweighting/IPCWmethod.R")
```


```{r}
num_obs = 1000
X = matrix(ncol = 0, nrow = 0)
mean_X = c()
X = get_cont_X(X, 'uniform',num_obs,1,4,"X1")
X = get_cont_X(X, 'uniform',num_obs,0.2,1,"X2")
time_point = 5
lambda_true = 0.01
beta = sim_beta(0, 0.6, time_point, mean_X)
seed = 4
if (ncol(X)!=length(beta)){
  stop("X and beta are not multiplicable")
}

lambda = exp(rowSums(sweep(X,2,beta,"*")))
dt = data.frame(lambda = lambda)
dt = cbind(dt,X)
var_name = colnames(X)
dt$event_time = get_T("exponential",num_obs, dt$lambda,seed)
# uncensor_prop>0.5, expected censored time > expected event time
#uncensor_prop>0.5, expected censored time < expected event time
uncensor_prop = runif(1,0.55,0.65)
dt$censor_time = get_C("exponential",num_obs, uncensor_prop, lambda,seed)
dt$observed_time = pmin(dt$event_time, dt$censor_time)
dt$sigma = as.numeric(dt$event_time<dt$censor_time)
dt$E = get_status(dt$observed_time, dt$sigma, time_point)
```


```{r}
true_surv = true_survival_function(dt$lambda,time_point)
wulala = ipcw_estimate(dt,time_point, var_name)
# View(data.frame(dt$lambda,dt$X1,dt$X2,dt$sigma, dt$observed_time,wulala,true_surv))
ols_ipcw = ols_error(true_surv,wulala)
```

```{r}
G____hat <-function(time_point, full_dt){
  km_censor = survfit(Surv(observed_time, 1-sigma)~1, data = full_dt)
  survest_Xi = stepfun(km_censor$time, c(1, km_censor$surv))
  return(survest_Xi)
}
```

```{r}
# interval = c(0,1,2.5,time_point)
Ghat = G____hat(time_point, dt)

multilayer_ipcw<-function(interval,train_data){
  total=data.frame()
  for(i in 1:(length(interval)-1)){
    start = interval[i]
    end = interval[i+1]
    numerator = Ghat(start)
    batch = train_data[train_data$observed_time>start,]
    batch$E = NULL
    batch$E = get_status(batch$observed_time,batch$sigma,end)
    # ifelse(batch$observed_time<end, batch$observed_time,end)
    batch$G = ifelse(batch$observed_time<end, Ghat(batch$observed_time),Ghat(end))
    batch$IPCW = ifelse(pmin(batch$event_time, end)<batch$censor_time, 
                                  numerator/batch$G, 
                                  0)
    if (ncol(total) == 0) {
      total = data.frame(batch)
    } else {
      total = rbind(total, batch)
    }
  }
  formula_str = paste("E ~", paste(var_name, collapse = " + "))
  formula = as.formula(formula_str)
  model = glm(formula, data = total, family = binomial, weights = IPCW)
  # multi_layer_ipcw_pred_prob = 1-(predict(multi_layer_ipcw_logistic_model, newdata = total[var_name], type = "response"))
  return(model)
}
```

```{r, warning=FALSE}
library(caret)
time_point = 5
max_intervals = 20
k = 5
Ghat = G____hat(time_point, dt)
folds = createFolds(dt$event_time, k = k)
results = data.frame(intervals = 1:max_intervals, performance = NA)
for (num_intervals in 1:max_intervals) {
  fold_performance = numeric(k)
  for (f in 1:k) {
    train_data = dt[-folds[[f]], ]
    test_data = dt[folds[[f]], ]
    interval = seq(0, time_point, length.out = num_intervals + 1)
    model = multilayer_ipcw(interval, train_data)
    test_data$pred_prob = 1 - predict(model, newdata = test_data[var_name], type = "response")
    test_true_surv = true_survival_function(test_data$lambda,time_point)
    fold_performance[f] = ols_error(test_true_surv, (test_data$pred_prob)^num_intervals)
}
  results$performance[num_intervals] = mean(fold_performance)
}
best_intervals = results$intervals[which.min(results$performance)]
print(paste("Optimal number of intervals:", best_intervals))
```

```{r}
opt_interval = seq(0, time_point, length.out = best_intervals + 1)
multi_ipcw_model = multilayer_ipcw(opt_interval, dt)
multi_layer_ipcw_pred_prob = 1-(predict(multi_ipcw_model, newdata = dt[var_name], type = "response"))
ols_multi_ipcw = ols_error(true_surv, (multi_layer_ipcw_pred_prob)^best_intervals)
```






